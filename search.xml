<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划</title>
    <url>/2020/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>参考：<a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">https://blog.csdn.net/u013309870/article/details/75193592</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2020/04/07/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>首先看一个题：<a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/burst-balloons/</a></p>
<p>这个题目可以使用分治法来做。</p>
<p>参考：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/burst-balloons/solution/dui-fen-zhi-fa-ti-jie-de-jie-du-by-chuck-bass/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/burst-balloons/solution/dui-fen-zhi-fa-ti-jie-de-jie-du-by-chuck-bass/</a></li>
<li><a href="https://leetcode-cn.com/problems/burst-balloons/solution/chao-xiang-xi-hui-su-dao-fen-zhi-dao-dp-by-niu-you/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/burst-balloons/solution/chao-xiang-xi-hui-su-dao-fen-zhi-dao-dp-by-niu-you/</a></li>
<li><a href="https://leetcode-cn.com/problems/burst-balloons/solution/cyu-yan-ti-jie-qian-xi-qu-jian-dpyu-fen-zhi-fa-by-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/burst-balloons/solution/cyu-yan-ti-jie-qian-xi-qu-jian-dpyu-fen-zhi-fa-by-/</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢?为什么不能用两次握手进行连接?</title>
    <url>/2020/04/06/%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<p>TCP 连接</p>
<p>我们先来补一下基础什么是 TCP 协议?传输控制协议是种面向连接、确保数据在端到端间可靠传输的协议。面向连接是插在发送数据前，需要先建立一条虚拟的链路，然后让数据在这条链路上“流动”完成传输。</p>
<p>ACK：用于对收到的数据进行确认，所确认的数据由确认序列号表示。</p>
<p>SYN：用作建立连接时的同步信号</p>
<p>FIN：表示后面没有数据需要发送，通常意昧着所建立的连接需要关闭了。</p>
<p>好了，到这里，TCP 的基础知识我们就知道了，下面我们就来看看为什么</p>
<p>是三次握手，而不是四次或者两次，为了让你更好的理解，我把知乎上一个高赞特别形象的比喻放在这里，希望对你有所帮助。</p>
<p><img src="https://p0.ssl.qhimgs4.com/t0109ea28835a3e16fc.webp" alt=""></p>
<p>两次和四次都会出现问题，三次就刚刚好，希望这张图能够让你更好的理解为什么是三次握手。</p>
<p>我们已经知道了 TCP 协议是三次握手，为什么是三次握手呢?我们先来看看下面这张 TCP 协议建立连接的时序图。</p>
<p><img src="https://p0.ssl.qhimgs4.com/t019775200c9ed236fc.webp" alt=""></p>
<p>总体来说就是呼叫、应答、回应，我们来详细的介绍每一步：</p>
<p>第一步： A 机器向 B机器发出一个数据包并将 SYN 设置为 1 ，表示希望建立连接。这个包中的序列号假设是 X。</p>
<p>第二步： B 机器收到 A机器发过来的数据包后，通过 SYN 得知这是一个建立连接的请求，于是发送一个响应包并将 SYN 、ACK 标记都置为 1。假设这个包中的序列号是 y ，而确认序列号必须是 x+l ，表示收到了 发过来的 SYN，TCP 中， SYN 被当作数据部分的一个字节。</p>
<p>第三步： A 收到 的响应包后需进行确认，确认包中将 ACK ，并将确认序列号设置为 y+ ，表示收到了来自B 的 SYN</p>
<p>经过这三步之后，两台服务器就建立连接了，可以进行通信数据传输了。为什么要三次握手呢?主要是为了信息对等和防止出现请求超时导致脏连接。</p>
<p>第一是为了保证两台机器信息对等，确保两台机器都没有什么问题：</p>
<p>只有三次握手之后才能够保证两台服务器都完全没有问题，各自具备发报和收报能力。</p>
<p><img src="https://p0.ssl.qhimgs4.com/t016ef9bcc61f20274c.webp" alt=""></p>
<p>为什么会出现脏连接?因为TTL 网络报文的生存时间往往都会超 TCP 请求超时时间，如果两次握手就可以创建连接 ，传输数据并释放连接后，第一个超时的连接请求才到达 B 机器的话，B 机器会以为是 A 创建新连接的请求，然后确认同意创建连接。因为 A 机器的状态不是 SYl_SENT ，所以直接丢弃了 B 的确认数据 ，以致最后只是 B 机器单方面创建连接完毕。</p>
<p>三次握手就可以解决这个问题，因为需要 A 服务器确认了才真正的建立了连接。</p>
<p>TCP 四次挥手</p>
<p>上面介绍了 TCP 协议连接，有连接就有断开，相对于三次连接，断开却需要四次挥手，怎么理解呢?先看下面这个场景：</p>
<p>A：B 啊，我不想玩了。</p>
<p>B：哦，你不想玩了啊，我知道了。</p>
<p>这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢?当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为半关闭的状态。</p>
<p>这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。</p>
<p>B：A 啊，好吧，我也不玩了，拜拜。</p>
<p>A：好的，拜拜。</p>
<p><img src="https://p0.ssl.qhimgs4.com/t0182b5b27f763e2c07.webp" alt=""></p>
<p>我们结合上面的时序图和场景再来分析一下 TCP 断开过程。</p>
<p>当 A 说“不玩了”，A 就进入 FIN_WAIT_1 的状态，B 收到“A 不玩”的消息后，发送知道了，B 就进入 CLOSE_WAIT 的状态。</p>
<p>A 收到“B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。虽然 TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间，最后 A 也会关闭的。</p>
<p>如果 B 没有跑路，发送了“B 也不玩了”的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢?则 B 会重新发一个“B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而 TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。</p>
<p>要求 A 等待 TIME_WAIT还有一个原因就是防止产生混乱，A 直接关闭了，但是这个时候 B是不知道的，可能在 A 关闭之前 B还发送了很多数据包，如果这时候 A 的端口被一个新的应用占用了的话，那么新的应用就会接收到上个连接中 B发送过来的数据包，这样就混乱了，虽然这个数据包是无效的，但是等待 TIME_WAIT 可以是一个双保险，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。</p>
<p>以上就是 TCP 协议三次握手，四次挥手的原因。</p>
<p>另外参考：<a href="https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 练习 4月</title>
    <url>/2020/04/02/LeetCode%20%E7%BB%83%E4%B9%A0%204%E6%9C%88/</url>
    <content><![CDATA[<h1 id="LeetCode-练习-4月"><a href="#LeetCode-练习-4月" class="headerlink" title="LeetCode 练习 4月"></a>LeetCode 练习 4月</h1><p><a href="https://leetcode.com/discuss/general-discussion/551411/30-day-leetcoding-challenge" target="_blank" rel="noopener">https://leetcode.com/discuss/general-discussion/551411/30-day-leetcoding-challenge</a></p>
<h2 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h2><h3 id="4-1-日-Single-Number"><a href="#4-1-日-Single-Number" class="headerlink" title="4.1 日  Single Number"></a>4.1 日  Single Number</h3><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> [2,2,1]<br><strong>Output:</strong> 1</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> [4,1,2,1,2]<br><strong>Output:</strong> 4</p>
<p>这道题主要的要求是：程序具有线性复杂度，并且最好不使用额外的内存。</p>
<p>除去这两个要求的话，有如下方法：</p>
<ul>
<li><p>第一种：先对序列进行排序，之后遍历一遍序列，如果存在一个数如 array[i] 的左边 array[i-1] 和右边 array[i+1] 均与 array[i] 不同，则这个数为要找的数（i=0以及i=n-1时进行特殊处理）</p>
</li>
<li><p>第二种：使用hashset，这是参考着<a href="https://www.cnblogs.com/grandyang/p/4130577.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4130577.html</a> 看的，我之前对于hashset了解并不多，这里正好也了解一下：<a href="https://blog.csdn.net/wds1181977/article/details/51424839" target="_blank" rel="noopener">https://blog.csdn.net/wds1181977/article/details/51424839</a> 可以看到，其实在java中hashset是通过hashmap实现的，只是在键值对方面hashset 是不同的键对应同一个键值对。根据hashset的思想，可以解决该问题：遍历序列，如果当前值不在hashset中，则放入hashset，否则将同样的值移除hashset。注意：在java中有hashset，在C++中使用的是unordered_set，解决代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.count(num)) st.erase(num);</span><br><span class="line">            <span class="keyword">else</span> st.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *st.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>但是由于上面条件的限制，不能使用上述两个方法。</p>
<p>开始我也没有想到，想了很长时间，想过通过数学的方法，加加减减得到结果，但是经过测试后不可行。</p>
<p>之后参考了网上的方法，使用*<em>C++的异或操作  ^ *</em> ，比如x=2,y=3 ,z=3.则x ^ y = 5，x^y^z = 2 , y ^ z = 0;</p>
<p>下面是解决方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">	&#123;</span><br><span class="line">		res ^= num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4月2日-Happy-Number"><a href="#4月2日-Happy-Number" class="headerlink" title="4月2日 Happy Number"></a>4月2日 Happy Number</h3><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p><strong>Example:</strong> </p>
<p><strong>Input:</strong> 19<br><strong>Output:</strong> true<br><strong>Explanation:</strong> 12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<p>解决代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 递归终止条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (st.count(n)) <span class="comment">// 如果又循环回来了</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	st.insert(n);</span><br><span class="line">	<span class="keyword">int</span> sum = getSum(n);<span class="comment">//获取到n经过拆分计算后的结果</span></span><br><span class="line">	<span class="keyword">return</span> isHappy(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; speNum;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		speNum.push_back(n % <span class="number">10</span>); <span class="comment">// 个位数</span></span><br><span class="line">		n = n / <span class="number">10</span>; <span class="comment">//去掉个位数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : speNum)</span><br><span class="line">	&#123;</span><br><span class="line">		result += num * num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码提交后显示我的代码运行时间是较长的，我看了那些运行时间很短的代码，他们很多用了些技巧，比如：如果1&lt;=n&lt;10的话，如果n=1或者n=7,那么就符合，否则就不符合。但是这样我感觉不好！因为你需要先知道1-10中符合条件的数。</p>
<h3 id="4月3日-Maximum-Subarray"><a href="#4月3日-Maximum-Subarray" class="headerlink" title="4月3日 Maximum Subarray"></a>4月3日 Maximum Subarray</h3><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong> [-2,1,-3,4,-1,2,1,-5,4],<br><strong>Output:</strong> 6<br><strong>Explanation:</strong> [4,-1,2,1] has the largest sum = 6.</p>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> result = maxSum(nums, left, right);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (left == right)<span class="comment">// 递归的基准情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> nums[left];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> maxLeftSum; <span class="comment">// 左半部分最大值</span></span><br><span class="line">		<span class="keyword">int</span> maxRightSum; <span class="comment">// 右半部分最大值</span></span><br><span class="line">		maxLeftSum = maxSum(nums, left, mid);</span><br><span class="line">		maxRightSum = maxSum(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 下面开始求中间连接的最大值</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> maxLeftBorderSum;</span><br><span class="line">		<span class="keyword">int</span> leftTempSum;</span><br><span class="line">		maxLeftBorderSum = leftTempSum = nums[mid];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) <span class="comment">// 从中间边界处向左扩展</span></span><br><span class="line">		&#123;</span><br><span class="line">			leftTempSum += nums[i];</span><br><span class="line">			<span class="keyword">if</span> (maxLeftBorderSum &lt; leftTempSum)</span><br><span class="line">			&#123;</span><br><span class="line">				maxLeftBorderSum = leftTempSum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> maxRightBorderSum;</span><br><span class="line">		<span class="keyword">int</span> rightTempSum;</span><br><span class="line">		maxRightBorderSum = rightTempSum = nums[mid + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">2</span>; i &lt;= right; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			rightTempSum += nums[i];</span><br><span class="line">			<span class="keyword">if</span> (maxRightBorderSum &lt; rightTempSum)</span><br><span class="line">			&#123;</span><br><span class="line">				maxRightBorderSum = rightTempSum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求左半部分，右半部分，中间部分三者最大值</span></span><br><span class="line">		<span class="keyword">return</span> max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a &gt;= b &amp;&amp; a &gt;= c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (b &gt;= a &amp;&amp; b &gt;= c)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4月4日-Move-Zeroes"><a href="#4月4日-Move-Zeroes" class="headerlink" title="4月4日 Move Zeroes"></a>4月4日 Move Zeroes</h3><p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong> <code>[0,1,0,3,12]</code><br><strong>Output:</strong> <code>[1,3,12,0,0]</code></p>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> zerosNum = <span class="number">0</span>; <span class="comment">// 存放0的数量</span></span><br><span class="line">	<span class="keyword">while</span> (zerosNum + i &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] == <span class="number">0</span>) <span class="comment">// 如果等于0，那么就将后面的所有数向前移动</span></span><br><span class="line">		&#123;</span><br><span class="line">			zerosNum++; <span class="comment">// 0的数量+1</span></span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// todo 将数组从索引j开始向前移动一个单位</span></span><br><span class="line">			moveForth(nums,j);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveForth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) <span class="comment">// 向前移动</span></span><br><span class="line">	&#123;</span><br><span class="line">		nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 最后一位设置为0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4月5日-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#4月5日-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="4月5日 Best Time to Buy and Sell Stock II"></a>4月5日 Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> [7,1,5,3,6,4]<br><strong>Output:</strong> 7<br><strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> [1,2,3,4,5]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> [7,6,4,3,1]<br><strong>Output:</strong> 0<br><strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tempStart = <span class="number">0</span>; <span class="comment">// 股票开始购买的时间</span></span><br><span class="line">	<span class="keyword">int</span> tempEnd = <span class="number">0</span>; <span class="comment">// 股票结束购买时间</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (prices[i] &gt; prices[i + <span class="number">1</span>]) <span class="comment">// 如果当前股票价格比后一天价格高</span></span><br><span class="line">		&#123;</span><br><span class="line">			result += prices[tempEnd] - prices[tempStart];</span><br><span class="line">			i++;</span><br><span class="line">			tempStart = i;</span><br><span class="line">			tempEnd = i;</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// 当天的股票不买，进入后一天</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		tempEnd = i;</span><br><span class="line">	&#125;</span><br><span class="line">	result += prices[tempEnd] - prices[tempStart];</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>在 Android Device Monitor 的 File Explorer 中，无法打开某些文件夹的解决方法</title>
    <url>/2020/03/31/%E5%9C%A8%20Android%20Device%20Monitor%20%E7%9A%84%20File%20Explorer%20%E4%B8%AD%EF%BC%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="在-Android-Device-Monitor-的-File-Explorer-中，无法打开某些文件夹的解决方法"><a href="#在-Android-Device-Monitor-的-File-Explorer-中，无法打开某些文件夹的解决方法" class="headerlink" title="在 Android Device Monitor 的 File Explorer 中，无法打开某些文件夹的解决方法"></a>在 Android Device Monitor 的 File Explorer 中，无法打开某些文件夹的解决方法</h1><p>参考：<a href="https://www.jianshu.com/p/acf9e8240467?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://www.jianshu.com/p/acf9e8240467?tdsourcetag=s_pctim_aiomsg</a></p>
<p>Android Device Monitor 的 File Explorer 中，列出了模拟器内的各种文件与文件夹，有的文件夹旁边明明有箭头符号，然而却打不开，比如下面的 data 文件夹：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3386108-7c8720c91f5b7709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp" alt=""></p>
<p>File Explorer</p>
<h1 id="1-分析"><a href="#1-分析" class="headerlink" title="1 分析"></a>1 分析</h1><p>因为 Android 的底层是 linux，所以每个文件夹都是有权限控制的，比如 data 的 Permissions（权限）是 <code>drwxrwx--x</code></p>
<p>我们来解释一下：</p>
<ul>
<li>第一个字符表示的是文件类型。如果是 d，则表示是文件夹。</li>
<li>后面跟着三个三元组。</li>
<li>共 10 个字符。</li>
</ul>
<p>三个三元组各有不同的含义：</p>
<ul>
<li>第一个组表示<strong>文件所有者</strong>的权限。</li>
<li>第二个组表示文件的<strong>组</strong>权限。</li>
<li>第三个组表示<strong>所有其他用户</strong>权限。</li>
</ul>
<p>三元组字符的含义（顺序是 <code>rwx</code>）：</p>
<ul>
<li><code>r</code> - 允许读（read）</li>
<li><code>w</code> - 允许写（write）</li>
<li><code>x</code> - 允许执行（execute）</li>
<li><code>-</code> - 没有上述某种权限（与位置有关）</li>
</ul>
<h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2 解决"></a>2 解决</h1><p>使用 Android SDK 中的 adb，为文件夹设置访问权限。</p>
<p>1、把 platform-tools 文件夹设置为环境变量：</p>
<p>找到 Android SDK 的安装路径，如果用的是 Android Studio，可以在 File → Settings → Android SDK 中找到安装路径：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3386108-0be9cc369b9238b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/857/format/webp" alt=""></p>
<p>Android SDK 配置</p>
<p>把它设置为系统环境变量：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3386108-fe5fa7c476263e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/351/format/webp" alt=""></p>
<p>系统环境变量</p>
<p>并加入 path。</p>
<p>2、打开 cmd，输入以下命令，为 data 文件夹设置相应的权限：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3386108-3223ee03e67a171d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/285/format/webp" alt=""></p>
<p>设置权限</p>
<p><em>备注：输入两次 exit，就能退出到 windows 盘符下。</em></p>
<p>这时，我们再打开 Android Device Monitor 的 File Explorer（会自动刷新），就可以正常打开 data 文件夹啦：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3386108-b2b968b92cec8ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/547/format/webp" alt=""></p>
<p>访问 data 文件夹</p>
<h1 id="3-命令解析"><a href="#3-命令解析" class="headerlink" title="3 命令解析"></a>3 命令解析</h1><p><code>adb shell</code> ：打开 adb shell 程序。<br><code>su</code> ：获取 root 权限。<br><code>chmod 权限 文件夹</code>：为文件夹设置权限。</p>
<p>这里的 775，表示的是 rwxrwxr-x，每一个数字表示的是一个二进制数，比如 7，即 111，表示为这一个三元组设置所有的 rwx 权限。</p>
<hr>
<p>更简单的做法是直接使用命令：</p>
<pre><code>adb root</code></pre><p>这样就不用一层一层文件夹设置权限啦O(∩_∩)O哈哈~</p>
<h1 id="关于解决su-not-found的方法"><a href="#关于解决su-not-found的方法" class="headerlink" title="关于解决su:not found的方法"></a>关于解决su:not found的方法</h1><p>参考：<a href="https://blog.csdn.net/yh18668197127/article/details/83313482" target="_blank" rel="noopener">https://blog.csdn.net/yh18668197127/article/details/83313482</a></p>
<p>adb shell之后su无法转到root权限,导致无法进入data/data/…</p>
<p>在Google查询之后发现是模拟器版本的问题</p>
<p>The play image has the Google Play store already installed and you can install apps, but there is no root access as it is a production build and not a debug build)</p>
<p><strong>Android Studio带(Google Play)的模拟器无法获得root权限</strong></p>
<p><strong>安装(Google APIs)的模拟器</strong></p>
<p>(注意图片Target里的（Google Play）和（Google APIs）)</p>
<p><img src="https://img-blog.csdn.net/20181023194917133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loMTg2NjgxOTcxMjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统（李治军）实验3 系统调用</title>
    <url>/2020/03/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%9D%8E%E6%B2%BB%E5%86%9B%EF%BC%89%E5%AE%9E%E9%AA%8C3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>主要参考：</p>
<ol>
<li><a href="https://blog.csdn.net/wangyi_lin/article/details/6921110" target="_blank" rel="noopener">https://blog.csdn.net/wangyi_lin/article/details/6921110</a></li>
<li><a href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/2-syscall/2-syscall.md" target="_blank" rel="noopener">https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/2-syscall/2-syscall.md</a></li>
</ol>
<p>这个实验我真的是做不下去了，对于我来说，真的是很难，汇编啥的只有一点点了解，基本就是mov命令cs ip等一些简单的东西。只能多看几遍了，第一遍看真的是啥也不懂。</p>
<p>下面先记录记录一下我在做实验3的时候遇到的一些不明白的地方，做一下汇总记录。</p>
<h2 id="intel汇编-和-AT-amp-T汇编-的区别"><a href="#intel汇编-和-AT-amp-T汇编-的区别" class="headerlink" title="intel汇编 和 AT&amp;T汇编 的区别"></a>intel汇编 和 AT&amp;T汇编 的区别</h2><p>参考：<a href="https://blog.csdn.net/kennyrose/article/details/7575952" target="_blank" rel="noopener">https://blog.csdn.net/kennyrose/article/details/7575952</a></p>
<h2 id="对于-asm-volatile-函数讲解"><a href="#对于-asm-volatile-函数讲解" class="headerlink" title="对于 __ asm __ volatile  函数讲解"></a>对于 __ asm __ volatile  函数讲解</h2><p>在实验手册中首先介绍了close系统调用，但是对于下面的代码不是很明白：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int close(int fd)</span><br><span class="line">&#123;</span><br><span class="line">    long __res;</span><br><span class="line">    __asm__ volatile (&quot;int $0x80&quot;</span><br><span class="line">        : &quot;&#x3D;a&quot; (__res)</span><br><span class="line">        : &quot;0&quot; (__NR_close),&quot;b&quot; ((long)(fd)));</span><br><span class="line">    if (__res &gt;&#x3D; 0)</span><br><span class="line">        return (int) __res;</span><br><span class="line">    errno &#x3D; -__res;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲解：这是gcc内嵌汇编。</p>
<p>第一个冒号后表示汇编代码输出结果<br>第二个冒号后表示在这段汇编执行前输入<br>a 表示eax<br>b 表示ebx<br>0 表示这段代码列出的第一个寄存器即eax<br>这段代码的意思是把<strong>NR_close装入eax 把fd装入ebx 调用int指令陷入内核，内核返回后将eax的内容作为结果输出到</strong>res中。</p>
<p>另外，下面博客介绍了GCC内嵌汇编的使用：插入C语言的一个汇编语言代码片段可以分成4部分，以“:”号加以分隔，其一般形式为：<strong><em>\</em>指令部：输出部：输入部：损坏部**</strong> <a href="https://blog.csdn.net/robbie1314/article/details/6329329" target="_blank" rel="noopener">https://blog.csdn.net/robbie1314/article/details/6329329</a></p>
<h2 id="对include-unistd-h中添加的-NR-XXX的解释"><a href="#对include-unistd-h中添加的-NR-XXX的解释" class="headerlink" title="对include/unistd.h中添加的\NR__XXX的解释"></a>对include/unistd.h中添加的<em>\</em>NR__XXX的解释</h2><p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200331170529.png" alt=""></p>
<p>“<em>\</em>NR__”是在Linux的源码中为每个系统调用加上的前缀。这里其实是Linux自己命名习惯，无关紧要，但是当时看着很不理解。</p>
<h2 id="关于sys-h-中-sys-call-table的介绍："><a href="#关于sys-h-中-sys-call-table的介绍：" class="headerlink" title="关于sys.h 中 sys_call_table的介绍："></a>关于sys.h 中 sys_call_table的介绍：</h2><p><a href="https://www.cnblogs.com/alantu2018/p/8991310.html" target="_blank" rel="noopener">https://www.cnblogs.com/alantu2018/p/8991310.html</a>  </p>
<p> <a href="https://www.cnblogs.com/wuchanming/p/4490622.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuchanming/p/4490622.html</a>  </p>
<p> <a href="https://blog.csdn.net/qq_41453285/article/details/103055378" target="_blank" rel="noopener">https://blog.csdn.net/qq_41453285/article/details/103055378</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>C++  使用问题记录</title>
    <url>/2020/03/30/C++%20%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="C-使用问题记录"><a href="#C-使用问题记录" class="headerlink" title="C++  使用问题记录"></a>C++  使用问题记录</h1><ol>
<li><p>将vector<char> 转化为 vector<string>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::vector&lt;char&gt; v;</span><br><span class="line">std::string str(v.begin(), v.end());</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符数组与string的相互转换：</p>
<p><strong>字符数组转化成string类型</strong><br>char ch [] = “ABCDEFG”;<br>string str(ch);//也可string str = ch;<br>或者<br>char ch [] = “ABCDEFG”;<br>string str;<br>str = ch;//在原有基础上添加可以用str += ch;</p>
<p><strong>将string类型转换为字符数组</strong><br>char buf[10];<br>string str(“ABCDEFG”);<br>length = str.copy(buf, 9);<br>buf[length] = ‘\0’;<br>或者<br>char buf[10];<br>string str(“ABCDEFG”);<br>strcpy(buf, str.c_str());//strncpy(buf, str.c_str(), 10);</p>
</li>
<li><p>Vector元素的遍历和修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">    &gt; File Name: vector.cpp</span></span><br><span class="line"><span class="comment">    &gt; Author: </span></span><br><span class="line"><span class="comment">    &gt; Mail: </span></span><br><span class="line"><span class="comment">    &gt; Created Time: Thu 13 Apr 2017 08:57:25 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        ivec.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历vector元素</span></span><br><span class="line">    <span class="comment">//1: 利用迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//2: 利用下标操作符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ivec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3: 利用范围for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : ivec)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改vector中的元素（前提条件是vector中已有元素，且以下方式均不能改变已有元素的个数）</span></span><br><span class="line">    <span class="comment">//1: 利用迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        *it = *it * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//2: 利用下标操作符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ivec[i] = ivec[i] * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ivec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//3: 利用范围for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ivec)<span class="comment">//注意此处是引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ std::vector指定位置插入</p>
<p><strong>1.初始化vector，一般有这几种方式：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">wstring</span>&gt; v1;                <span class="comment">//创建一个空的wstring类型的vector</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">wstring</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>, <span class="string">"c"</span>)</span></span>;       <span class="comment">//创建一个容量为3，全部初始化L"c"</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>)</span></span>;                      <span class="comment">//创建容量为5，数据类型为int的vector</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;                     <span class="comment">//创建一个从v3拷贝过来的vector</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v5 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;       <span class="comment">//C++11才支持，直接值初始化，最方便</span></span><br></pre></td></tr></table></figure>

<p>第五种方法：  vector<int> v5{1,2,3.0,4,5,6,7};</p>
<p>v5初始化为列表中元素的拷贝，列表中元素必须与v5的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换</p>
<p><strong>2.在指定位置插入元素：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v2.insert(v2.<span class="built_in">begin</span>()+<span class="number">4</span>, <span class="string">"3"</span>);   <span class="comment">//在指定位置，例如在第五个元素前插入一个元素</span></span><br><span class="line"> </span><br><span class="line">v2.insert(v2.<span class="built_in">end</span>(), <span class="string">"3"</span>);   <span class="comment">//在末尾插入一个元素</span></span><br><span class="line"> </span><br><span class="line">v2.push_back(<span class="string">"9"</span>);   <span class="comment">//在末尾插入一个元素</span></span><br><span class="line"> </span><br><span class="line">v2.insert(v2.<span class="built_in">begin</span>(), <span class="string">"3"</span>);   <span class="comment">//在开头插入一个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>3.删除数据：</strong></p>
<pre><code>v2.erase(v2.begin()); //删除开头的元素

v2.erase(v2.begin(),v2.end); //删除[begin,end]区间的元素

v2.pop_back();   //删除最后一个元素</code></pre><p>4.vector其他函数介绍：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   函数                                   说明</span><br><span class="line"> </span><br><span class="line">c.assign(beg,<span class="built_in">end</span>)            <span class="comment">//将[beg; end)区间中的数据赋值给c。</span></span><br><span class="line"> </span><br><span class="line">c.assign(n,elem)             <span class="comment">//将n个elem的拷贝赋值给c。</span></span><br><span class="line">    </span><br><span class="line">c.at(idx)                    <span class="comment">//传回索引idx所指的数据，如果idx越界，抛出out_of_range。</span></span><br><span class="line">    </span><br><span class="line">c.back()                     <span class="comment">//传回最后一个数据，不检查这个数据是否存在。</span></span><br><span class="line">    </span><br><span class="line">c.<span class="built_in">begin</span>()                    <span class="comment">//传回迭代器中的第一个数据地址。</span></span><br><span class="line">    </span><br><span class="line">c.capacity()                 <span class="comment">//返回容器中数据个数。</span></span><br><span class="line">    </span><br><span class="line">c.<span class="built_in">clear</span>()                    <span class="comment">//移除容器中所有数据。</span></span><br><span class="line">    </span><br><span class="line">c.empty()                    <span class="comment">//判断容器是否为空。</span></span><br><span class="line"> </span><br><span class="line">c.<span class="built_in">end</span>()                      <span class="comment">//指向迭代器中的最后一个数据地址。</span></span><br><span class="line"> </span><br><span class="line">c.erase(pos)                 <span class="comment">//删除pos位置的数据，传回下一个数据的位置。</span></span><br><span class="line"> </span><br><span class="line">c.erase(beg,<span class="built_in">end</span>)             <span class="comment">// 删除[beg,end)区间的数据，传回下一个数据的位置。</span></span><br><span class="line"> </span><br><span class="line">c.front()                    <span class="comment">//传回第一个数据。</span></span><br><span class="line">    </span><br><span class="line">get_allocator                <span class="comment">//使用构造函数返回一个拷贝。</span></span><br><span class="line">    </span><br><span class="line">c.insert(pos,elem)           <span class="comment">//在pos位置插入一个elem拷贝，传回新数据位置。</span></span><br><span class="line"> </span><br><span class="line">c.insert(pos,n,elem)         <span class="comment">//在pos位置插入n个elem数据。无返回值。</span></span><br><span class="line"> </span><br><span class="line">c.insert(pos,beg,<span class="built_in">end</span>)        <span class="comment">//在pos位置插入在[beg,end)区间的数据。无返回值。</span></span><br><span class="line">    </span><br><span class="line">c.max_size()                 <span class="comment">//返回容器中最大数据的数量。</span></span><br><span class="line">    </span><br><span class="line">c.pop_back()                 <span class="comment">//删除最后一个数据。</span></span><br><span class="line">    </span><br><span class="line">c.push_back(elem)            <span class="comment">//在尾部加入一个数据。</span></span><br><span class="line"> </span><br><span class="line">c.rbegin()                   <span class="comment">//传回一个逆向队列的第一个数据。</span></span><br><span class="line">    </span><br><span class="line">c.rend()                     <span class="comment">//传回一个逆向队列的最后一个数据的下一个位置。</span></span><br><span class="line"> </span><br><span class="line">c.resize(num)                <span class="comment">//重新指定队列的长度。</span></span><br><span class="line"> </span><br><span class="line">c.reserve()                  <span class="comment">//保留适当的容量。</span></span><br><span class="line"> </span><br><span class="line">c.<span class="built_in">size</span>()                     <span class="comment">//返回容器中实际数据的个数。</span></span><br><span class="line"> </span><br><span class="line">c1.swap(c2)                  <span class="comment">//将c1和c2元素互换。</span></span><br><span class="line"> </span><br><span class="line">swap(c1,c2)                  <span class="comment">//同上操作。</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">vector</span>&lt;Elem&gt; c               <span class="comment">//创建一个空的vector。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Elem&gt; <span class="title">c1</span><span class="params">(c2)</span>          <span class="comment">//复制一个vector。</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span> &lt;Elem&gt; <span class="title">c</span><span class="params">(n)</span>           <span class="comment">//创建一个vector，含有n个数据，数据均已缺省构造产生。</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span> &lt;Elem&gt; <span class="title">c</span><span class="params">(n, elem)</span>     <span class="comment">//创建一个含有n个elem拷贝的vector。</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span> &lt;Elem&gt; <span class="title">c</span><span class="params">(beg,<span class="built_in">end</span>)</span>     <span class="comment">//创建一个以[beg;end)区间的vector。</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line">c.~ vector &lt;Elem&gt;()          //销毁所有数据，释放内存。</span><br><span class="line">   </span><br><span class="line"><span class="keyword">operator</span>[]                   <span class="comment">//返回容器中指定位置的一个引用。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>对TCP ，GBN，SR的一点理解总结</title>
    <url>/2020/03/29/%E5%AF%B9TCP%20%EF%BC%8CGBN%EF%BC%8CSR%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%E4%B8%8E%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<h1 id="对TCP-，GBN，SR的一点理解总结"><a href="#对TCP-，GBN，SR的一点理解总结" class="headerlink" title="对TCP ，GBN，SR的一点理解总结"></a>对TCP ，GBN，SR的一点理解总结</h1><p>看到这个题目应该就知道这是大学生写的，这篇博客的写作是因为我在复习《计算机网络自顶向下方法》时对TCP进行的部分总结。看过这本书的人应该都知道，书中在介绍TCP使用的流水线可靠数据传输之前，先介绍了两种能够保证可靠数据传输的模型：GBN 、 SR</p>
<h2 id="对于GBN与SR的讲解"><a href="#对于GBN与SR的讲解" class="headerlink" title="对于GBN与SR的讲解"></a>对于GBN与SR的讲解</h2><p>参考：<a href="https://blog.csdn.net/qq_22238021/article/details/80325285" target="_blank" rel="noopener">https://blog.csdn.net/qq_22238021/article/details/80325285</a></p>
<h3 id="rdt-3-0-协议性能分析"><a href="#rdt-3-0-协议性能分析" class="headerlink" title="rdt 3.0 协议性能分析"></a>rdt 3.0 协议性能分析</h3><p>假设有两台主机，分别位于美国西海岸和东海岸，它们之间的往返传播实验 RTT 大约为 30ms，假定它们通过一条速率 R 为 1Gbps 的信道相连。包括首部字段和数据的分组长 L 为 1000 bytes(8000 bits)，所以发送一个分组进入 1Gbps 链路实际所需时间是：</p>
<p>t_trans = L / R = (8000 bit/pkt) / (10^9 bit/s) = 8 μs/pkt</p>
<p>所以，如果发送端在 t = 0 时刻开始发送分组，则在 8μs 后，该分组全部进入了发送端信道。接着该分组经过 15ms 的旅途到达接收端，即该分组的最后 1 bit 在时刻 t = RTT/2 + L/R = 15.008ms 时到达接收端。假设 ACK 分组很小，可以忽略其发送时间，且接收端一旦收到一个数据分组的最后 1bit 后立刻发送 ACK，则 ACK 在时刻 t = RTT + L/R = 30.008ms 时回送到发送端。也就是说，经过 30.008ms 后发送端才可以发送下一个分组。</p>
<p>设<strong>利用率</strong>为：<strong>发送端实际忙于将发送比特送进信道的那部分时间与发送时间之比</strong>。则</p>
<p>U_sender = (L/R) / (RTT + L/R) = 0.008 / 30.008 = 0.00027</p>
<p>可以看到，利用率极其低下，这是不可容忍的，所以我们需要改进性能。</p>
<h3 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h3><p>流水线技术是解决这种特殊性能问题的一个非常简单的方法：不使用停等方式运行，允许发送端发送多个分组而无需等待确认。</p>
<p>虽然流水线可以直线提升 rdt 3.0 协议的性能，但是也会带来如下的影响：</p>
<ul>
<li>必须增加序号的范围。因为每个传输中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中尚未确认的分组</li>
<li>协议的发送端和接收端也必须缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组，接收方或许也需要缓存那些已正确接收的分组</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏和延时过大的分组。</li>
</ul>
<p>解决流水线的差错恢复有两种基本方法，分别为 <strong>回退 N 步（Go-Back-N, GBN）</strong> 和 <strong>选择重传（Selective Repeat, SR）</strong>。</p>
<h3 id="GBN-协议（回退-N-步协议）"><a href="#GBN-协议（回退-N-步协议）" class="headerlink" title="GBN 协议（回退 N 步协议）"></a>GBN 协议（回退 N 步协议）</h3><p>在 GBN 协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数 N。</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210012.png" alt=""></p>
<p>上图显示了发送方看到的 GBN 协议的序号范围。将<strong>基序号（base）</strong>定义为最早的未确认分组的序号，将<strong>下一个序号（nextseqnum）</strong>定义为最小的未使用序号（即下一个待发分组的序号），则可将序号范围分割成 4 段。在 [0, base-1] 段内的序号对应于已经发送并确认的分组。[base, nextseqnum-1] 段对应已经发送但未被确认的分组。[nextseqnum, base+N-1] 段内的序号能用于那些要立即发送的分组，如果有数据来自于上层的话。最后，大于或等于 base+N 的序号是不能使用的，直到当前流水线中未确认的分组（特别是序号为 base 的分组）已得到确认为止。</p>
<p>在上图中，把 [base, base+N-1] 看做一个长度为 N 的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N 常被称为<strong>窗口长度（window size）</strong>，GBN 协议也常被称为<strong>滑动窗口协议（sliding-window protocol）</strong>。至于为什么需要限制 N 的范围，是因为这是流量控制的方法之一。</p>
<p>在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是 k，则该序号范围是 [0, 2^k - 1]。在一个有限的序号范围内，所有涉及序号的运算必须使用模 2^k 运算。</p>
<p>下图是GBN 协议发送方扩展 FSM 描述：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210043.png" alt=""></p>
<p>发送方必须响应三种类型的事件：</p>
<ul>
<li><strong>上层的调用</strong>。当上层调用 <code>rdt_send()</code> 时，发送方首先检查发送窗口是否已满，即是否有 N 个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送，并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会儿再试。在实际实现中，发送方更可能缓存这些数据，或者使用同步机制（如一个信号量或标志）允许上层在仅当窗口不满时才调用 <code>rdt_send()</code>。</li>
<li><strong>收到一个ACK</strong>。在 GBN 协议中，对序号为 n 的分组的确认采取<strong>累积确认（cumulative acknowledgment）</strong>的方式，表明接收方已正确接收到序号为 n 的以前且包括 n 在内的所有分组。</li>
<li><strong>超时事件</strong>。协议的名字“回退 N 步”来源于出现丢失和时延过长分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。如果出现超时，<strong>发送方重传所有已发送但未被确认过的分组</strong>。上图中发送方仅使用一个定时器，如果收到了一个 ACK，但仍有已发送但未被确认的分组，则定时器被重新启动。如果没有已发送但未被确认的分组，该定时器被终止。</li>
</ul>
<p>下图是 GBN 协议接收方扩展 FSM 描述：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210102.png" alt=""></p>
<p>如果一个序号为 n 的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为 n - 1 的分组），则接收方为分组 n 发送一个 ACK，并将该分组中的数据部分交付到上层。</p>
<p>在所有其他情况下，接收方将<strong>丢弃</strong>该分组，并<strong>为最近按序接收的分组重新发送 ACK</strong>。</p>
<p>注意到因为一次交付给上层一个分组，<strong>如果分组 k 为已接受并交付，则所有序号比 k 小的分组也已经交付</strong>。因此，使用累积确认是 GBN 的一个自然的选择。</p>
<p>虽然 GBN 协议看起来很浪费，因为它会丢弃一个正确接收（但失序）的分组。但这样做是有道理的。因为接收方必须将数据按序交付给上层，假设现在期望接收分组 n，而分组 n + 1 却到了，因为数据必须按序交付，所以接收方可能缓存分组 n + 1，然后，在它收到并交付分组 n 后，再将该分组交付到上层。但是，如果分组 n 丢失，则该分组及分组 n + 1 最终将在发送方根据 GBN 重传规则而被重传，所以，接收方只需要直接丢弃分组 n + 1 即可。</p>
<p>这种方法的优点是<strong>接收方不需要缓存任何失序分组</strong>，<strong>唯一需要维护的信息就是下一个按序接收的分组的序号</strong>。缺点就是<strong>随后对该分组的重传也许会丢失或出错，进而引发更多的重传。</strong></p>
<p>可以看到，GBN 协议本身相对于 rdt 3.0 协议有了长足进步，但是仍然有它自己的性能问题，尤其是当窗口长度和带宽时延都很大的时，流水线中有很多分组更是如此。任何单个分组的差错就能引起 GBN 协议重传大量分组，事实上是很多分组根本没必要重传，所以，有了一个更加优化的协议，就是下面要说的 <strong>选择重传（SR）</strong> 协议。</p>
<h3 id="SR-协议（选择重传协议）"><a href="#SR-协议（选择重传协议）" class="headerlink" title="SR 协议（选择重传协议）"></a>SR 协议（选择重传协议）</h3><p>SR 协议在 GBN 协议的基础上进行了改进，它通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。<strong>选择重传协议只重传真正丢失的分组.</strong></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210123.png" alt=""></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210144.png" alt=""></p>
<p><strong>选择重传的接收窗口与发送窗口一样大.选择重传协议允许与接收窗口一样多的分组失序到达,并保存这些失序到达的分组,直到连续的一组分组被交付给应用层.因为发送窗口与接收窗口是相同的,所以发送出来的所有分组都可以失序到达,而且会被保留直到交付为止.但是必须强调一点,在一个可靠的协议中,接收方永远不会把分组失序地交给应用层.在他们被交付给应用层之前,先要等待那些更早发出来的分组到达.</strong></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210204.png" alt=""></p>
<p><strong>计时器</strong></p>
<p><strong>理论上选择重传协议要为每个分组使用一个计时器.当某个计时器超时后,只有相应的分组被重传.换而言之,返回N协议将所有的分组当做一个整体对待,而选择重传协议则分别对待每一个分组.但是大多数SR的运输层仅使用了一个计时器. 注意只使用一个计时器而做到跟踪所有发出去的分组的情况的做法是:标记发出分组,当ACK=Sf 时,将窗口滑过所有连续的已确认的分组,如果还有未确认的分组,则重发所有检测到的未被确认的分组并重启计时器,如果所有分组都被确认了则停止计时器.</strong></p>
<p><strong>确认</strong></p>
<p><strong>在GBN中确认值(ACK) 是累计的,它定义了下一个希望接收的分组序号,同时也证实了此前所有的分组都已经被完好的接收了.在SR中,确认号(ACK)只定义完好接收的那一个分组的序号,并不反馈任何其他分组的信息.</strong></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210224.png" alt=""></p>
<p>下图描述了发送方与接收方的序号空间：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210250.png" alt=""></p>
<p>发送方的事件与动作：</p>
<ul>
<li><strong>从上层收到数据</strong>。当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在 GBN 中一样，要么将数据缓存，要么将其返回给上层以便以后传输。</li>
<li><strong>超时</strong>。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。</li>
<li><strong>收到ACK</strong>。如果收到 ACK，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。若该分组的序号等于 send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。</li>
</ul>
<p>接收方的事件与动作：</p>
<ul>
<li><strong>序号在 [rcv_base, rcv_base+N-1] 内的分组被正确接收</strong>。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收端的基序号（rcv_base），则该分组以及以前缓存的序号连续的（起始于 rcv_base 的）分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li>
<li><strong>序号在 [rcv_base-N, rcv_base-1] 内的分组被正确收到</strong>。在此情况下，必须产生一个 ACK，即使该分组是接收方以前确认过的分组。</li>
<li><strong>其他情况</strong>。忽略该分组。</li>
</ul>
<p>注意上面的第二步，接收方需要重新确认（而不是忽略）已收到过的那些序号小于当前窗口基序号的分组。为什么要返回 ACK？加入按照上图中所示的发送方和接收方的序号空间，如果分组 send_base 的 ACK 没有从接收方传播回发送方，则发送方最终将重传分组 send_base，即使显然接收方已经收了该分组。<strong>如果接收方不确认该分组，则发送方窗口将永远不能向前滑动</strong>。</p>
<p>上面的例子说明了对于 SR 协议（和很多其他协议一样） 对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总能看到相同的结果。也就是说，发送方和接收方的窗口并不总是一致。</p>
<h4 id="窗口长度与序号空间大小"><a href="#窗口长度与序号空间大小" class="headerlink" title="窗口长度与序号空间大小"></a>窗口长度与序号空间大小</h4><p>下面这个例子说明了，如果窗口长度与序号空间大小选择不当，将会产生严重的后果。</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200403210312.png" alt=""></p>
<p>在这个例子中，有四个分组序号 0、1、2、3 且窗口长度为 3。假定发送了分组 0 至 2，并且接收方被正确接收且确认了。此时，接收方窗口落在 4、5、6 个分组上，其序号分别为 3、0、1.现在考虑两种情况。</p>
<p>在第一种情况下，如上图中的 a 图所示，对前 3 个分组的 ACK 丢失，因此发送方重传这些分组。因此，接收方下一步要接收序号为 0 的分组，即第一个发送分组的副本。</p>
<p>在第二种情况下，如上图中的 b 图所示，对前 3 个分组的 ACK 都被正确交付。因此发送方向前移动窗口并发送第 4、5、6 个分组，其序号分别为 3、0、1.序号为 3 的分组丢失，但序号为 0 的分组到达（一个包含新数据的分组）。</p>
<p>显然，接收方并不知道发送方那边出现了什么问题，对于接收方自己来说，上面两种情况是<strong>等价</strong>的。没有办法区分是第一个分组的重传还是第 5 个分组的初次传输。所以，窗口长度比序号空间小 1 时协议无法正常工作。但窗口应该有多小呢？</p>
<p>答案是：<strong>窗口长度必须小于或等于序号空间大小的一半</strong>。</p>
<h3 id="可靠数据传输过程中的分组重新排序问题"><a href="#可靠数据传输过程中的分组重新排序问题" class="headerlink" title="可靠数据传输过程中的分组重新排序问题"></a>可靠数据传输过程中的分组重新排序问题</h3><p>在前面的所有假设中，我们都是假定分组在发送方与接收方之间的信道中不能被重新排序。但是当连接两端的信道是一个网络时，分组重新排序是可能会发生的。</p>
<p>分组重新排序的一个表现就是一个具有序号或确认号 x 的分组的旧副本可能会出现，即使发送方或接收方的窗口中都包含 x。</p>
<p>对于分组重新排序，信道可被看成基本上是在缓存分组，并在将来任意时刻自然地释放出这些分组。由于序号可以被重新使用，那么必须小心，以免出现这样的冗余分组。</p>
<p>实际应用中采用的方法是：**确保一个序号不被重新使用，直到发送方“确信”任何先前发送的序号为 x 的分组都不再在网络中为止。通过假定一个分组在网络中的“存活”时间不会超过某个固定最大时间量来做到这一点。在高速网络的 TCP 扩展中，最长的分组寿命被假定为大于 3 分钟 [RFC 1323]。</p>
<h2 id="对于TCP，GBN，SR之间关系的总结"><a href="#对于TCP，GBN，SR之间关系的总结" class="headerlink" title="对于TCP，GBN，SR之间关系的总结"></a>对于TCP，GBN，SR之间关系的总结</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><h4 id="GBN："><a href="#GBN：" class="headerlink" title="GBN："></a>GBN：</h4><ul>
<li>如果某个报文段没有被正确接收，则从这个报文段到后面的报文段都要重新发送。</li>
<li>采用累计应答的方式。例如接收端返回ACK=3，则证明报文段3以及之前的报文段都被正确接收。<ul>
<li>这里顺便解释一下为什么GBN可以采用累计应答的方式？怎么就能保证3之前的被正确接收了呢？这还要由GBN的工作机制来决定：在GBN机制下，在接收端的运输层一次只交付给上层一个分组，并且保证是按序交付的，因此如果分组k已接收，则所有序号小于k的分组也已经交付了。</li>
</ul>
</li>
<li>接收端不对失序到达的分组进行缓存。</li>
</ul>
<h4 id="SR："><a href="#SR：" class="headerlink" title="SR："></a>SR：</h4><ul>
<li>接收方设置缓存区，用于接收失序到达的分组。（从这里可以感受到，所谓的<strong>GBN中的发送端窗口</strong>和<strong>SR中的发送端与接收端的窗口</strong>其实就是缓存区，用于缓存分组。注意，由于GBN是单个分组交付，不设置缓存区，所以GBN的接收端是没有窗口的）</li>
<li>为每个报文段设置单独的计时器，单个分组计时器超时只重发这一个报文段。</li>
<li>接收端返回ACK是当前接收成功报文段的序号，SR不采用累计应答的方式。</li>
</ul>
<h4 id="TCP："><a href="#TCP：" class="headerlink" title="TCP："></a>TCP：</h4><ul>
<li>TCP使用累计应答的方式。这一点与GBN类似。</li>
<li>TCP在接收端会设置缓存，来缓存正确接收但是失序的分组，这点与SR类似。（实际上TCP RFC并没有对接收端要怎样处理失序到达的分组提出要求，但是在接收端设置缓存是实践中大家都采用的方法）</li>
<li>TCP使用快速重传机制：如果收到对于一个特定报文段的3个冗余ACK，则在超时事件发生前就会对该报文段进行重传，这大大节约了时间。</li>
<li>注意：TCP中的ACK是指接收端希望从发送端收到的下一字节的序号。例如发送端发送了编号为0-5的字节，这时接收端成功接收后就会发送ACK为6。</li>
<li>注意：这里介绍的TCP这是理论上的，在实际使用过程中，大家加入了很多其他的机制等。目前计网学习的都是基础理论的知识。</li>
</ul>
<p>这里推荐一个教材附加的网址：<a href="http://www.ccs-labs.org/teaching/rn/animations/gbn_sr/" target="_blank" rel="noopener">http://www.ccs-labs.org/teaching/rn/animations/gbn_sr/</a></p>
<p>通过小程序来形象的模拟了GBN和SR的工作过程！</p>
<p>看了一个提问产生论文写作想法：<a href="https://stackoverflow.com/questions/12614393/differences-between-tcp-and-go-back-n" target="_blank" rel="noopener">https://stackoverflow.com/questions/12614393/differences-between-tcp-and-go-back-n</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>自己在githubpages + hexo 搭建自己博客遇到的问题</title>
    <url>/2020/03/29/%E8%87%AA%E5%B7%B1%E5%9C%A8githubpages%20+%20hexo%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="自己在githubpages-hexo-搭建自己博客遇到的问题"><a href="#自己在githubpages-hexo-搭建自己博客遇到的问题" class="headerlink" title="自己在githubpages + hexo 搭建自己博客遇到的问题"></a>自己在githubpages + hexo 搭建自己博客遇到的问题</h1><p>搭建过程可以参考：<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></p>
<p>下面是我在这一过程中遇到的问题</p>
<ol>
<li>侧栏中的“日志”点击，产生404错误，之后hexo s 进入本地模式后，点击出现错误：Cannot GET /archives/%7C%7C%20archive/</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/qq_36852780/article/details/104680152?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_36852780/article/details/104680152?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
<p><strong>访问的链接是<code>域名/archives/%7C%7C%20archive/</code>, 可见后面的多余了, 问题就是删除后面多余字符</strong></p>
<p>解决多余字符</p>
<p>posts的<code>class=&quot;site-state-item site-state-posts&quot;</code></p>
<p>打开<code>博客根目录/themes/next/layout/_macro/sidebar.swig</code>, 搜索class的值, 快速定位错误位置.</p>
<p><strong>修改之前:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if config.archive_dir !&#x3D; &#39;&#x2F;&#39; and site.posts.length &gt; 0 %&#125;</span><br><span class="line">             &lt;div class&#x3D;&quot;site-state-item site-state-posts&quot;&gt;</span><br><span class="line">             &#123;% if theme.menu.archives %&#125;</span><br><span class="line">               &lt;a href&#x3D;&quot;&#123;&#123; url_for(theme.menu.archives).split(&#39;||&#39;)[0] | trim &#125;&#125;&quot;&gt;</span><br><span class="line">             &#123;% else %&#125;</span><br><span class="line">               &lt;a href&#x3D;&quot;&#123;&#123; url_for(config.archive_dir) &#125;&#125;&quot;&gt;</span><br><span class="line">             &#123;% endif %&#125;</span><br><span class="line">                 &lt;span class&#x3D;&quot;site-state-item-count&quot;&gt;&#123;&#123; site.posts.length &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                 &lt;span class&#x3D;&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&#39;state.posts&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">               &lt;&#x2F;a&gt;</span><br><span class="line">             &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>


<p><strong>修改之后:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if config.archive_dir !&#x3D; &#39;&#x2F;&#39; and site.posts.length &gt; 0 %&#125;</span><br><span class="line">              &lt;div class&#x3D;&quot;site-state-item site-state-posts&quot;&gt;</span><br><span class="line">                &lt;a href&#x3D;&quot;&#123;&#123; url_for(config.archive_dir) &#125;&#125;&quot;&gt;</span><br><span class="line">                  &lt;span class&#x3D;&quot;site-state-item-count&quot;&gt;&#123;&#123; site.posts.length &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                  &lt;span class&#x3D;&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&#39;state.posts&#39;) &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">                &lt;&#x2F;a&gt;</span><br><span class="line">              &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>将中间的判断删掉, 保留下面else的内容即可解决该问题</p>
<ol start="2">
<li>为文章添加标签和分类：参考：<a href="https://juejin.im/post/5cc11c41f265da038f7745b5" target="_blank" rel="noopener">https://juejin.im/post/5cc11c41f265da038f7745b5</a></li>
</ol>
<ol start="3">
<li><p>为博客添加文章搜索功能：参考：<a href="http://xhksun.com/2019/03/10/hexo-Next-主题添加搜索功能/" target="_blank" rel="noopener">http://xhksun.com/2019/03/10/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</a></p>
<h2 id="安装相关插件"><a href="#安装相关插件" class="headerlink" title="安装相关插件"></a>安装相关插件</h2><p>首先安装搜索插件： <code>hexo-generator-searchdb</code></p>
<p>在hexo路径文件夹下执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>安装完成，在hexo的配置文件<code>_config.yml</code>中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>Next 主题自带搜索设置，编辑主题配置文件：<code>_config.yml</code></p>
<p>找到文件中 Local search 的相关配置，设为 <code>true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<h2 id="hexo-重新部署"><a href="#hexo-重新部署" class="headerlink" title="hexo 重新部署"></a>hexo 重新部署</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>给Hexo Next设置阅读全文</p>
<p>参考：<a href="https://www.jianshu.com/p/d335569a6238" target="_blank" rel="noopener">https://www.jianshu.com/p/d335569a6238</a></p>
<p>Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，但这会使你的首页篇幅过于冗长，针对这个问题我们可以这么做：</p>
<p>用编辑器打开themes/next 目录下的_config.yml文件</p>
<p>找到代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">      enable: false</span><br><span class="line">      length: 150</span><br></pre></td></tr></table></figure>

<p>将enable的 false改成true，length可以设定文章预览的文本长度。</p>
<p>修改后重启即可。</p>
</li>
<li><p>next主题配置时链接图标丢失解决方案</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11129189-fb41ff3e1688e2cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt=""></p>
</li>
</ol>
<p>参考：<a href="https://www.jianshu.com/p/a1777c2098b0" target="_blank" rel="noopener">https://www.jianshu.com/p/a1777c2098b0</a></p>
<p>但是按着上面博客中的配置会出现 Cannot GET /%20/ 的问题。20%表示的是空格，所以多了个空格路径不对。以archives为例，改成“ archives: /archives/|| archive”就可以了。</p>
<ol start="6">
<li><p>如何添加新的图标：</p>
<p>在<a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener">http://www.fontawesome.com.cn/faicons/</a> 网站中搜索图标，之后复制该网站的图标名称。</p>
<p>例如我们需要archive的图标，搜索后出现如下结果：</p>
<p><img src="C:%5CUsers%5Cdell%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200329142300580.png" alt="image-20200329142300580"></p>
<p>选择一个名字，比如我选择archive ,在根目录/theme/next/_config.yml 中需要的地方设置</p>
<p>例如：<img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200329142549.png" alt=""></p>
</li>
</ol>
<p>这样就可以了，重新部署一下。</p>
<ol start="7">
<li><p>最下面选择页面部分，向左的箭头和向右的箭头没有，显示代码：i class= fa fa-angle-right /i</p>
<p>解决方法：</p>
<p>打开主题文件<code>themes/你的主题/layout/_partial/pagination.ejs</code>文件，修改代码：</p>
<p>修改前：</p>
<pre><code>&lt;%- paginator({
    prev_text: &quot;&lt;i class=&apos;fa fa-angle-left&apos;&gt;&lt;/i&gt;&quot;,
    next_text: &quot;&lt;i class=&apos;fa fa-angle-right&apos;&gt;&lt;/i&gt;&quot;
}) %&gt;</code></pre><p>修改后：</p>
<pre><code>&lt;%- paginator({
    prev_text: &quot;&lt;i class=&apos;fa fa-angle-left&apos;&gt;&lt;/i&gt;&quot;,
    next_text: &quot;&lt;i class=&apos;fa fa-angle-right&apos;&gt;&lt;/i&gt;&quot;,
    escape: false
}) %&gt;</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2020/03/24/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯法实际是一种避免不必要搜索的穷举式搜索法。</p>
<p>用回溯法解题一般步骤：</p>
<ol>
<li>确定问题解空间，判断是使用子集树还是使用排列树</li>
<li>以深度优先的方式搜索解空间树，在搜索过程中要判断要是用剪枝函数避免无效搜索。</li>
</ol>
<p>回溯算法可分为<strong>递归回溯</strong>和<strong>迭代回溯</strong></p>
<p>这篇文章使用<strong>递归回溯</strong>来进行解决，递归回溯更加简单直观，便于理解。</p>
<h4 id="递归回溯算法步骤："><a href="#递归回溯算法步骤：" class="headerlink" title="递归回溯算法步骤："></a>递归回溯算法步骤：</h4><p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200324164158.png" alt=""></p>
<h4 id="子集树实例：解决-0-1-背包问题"><a href="#子集树实例：解决-0-1-背包问题" class="headerlink" title="子集树实例：解决 0 1 背包问题"></a>子集树实例：解决 0 1 背包问题</h4><p>0 1 背包问题适合使用子集树来进行解决，对子集树的描述如下：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200326150128.png" alt=""></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200326151435.png" alt=""></p>
<p>Package.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Package</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> bestPrice = <span class="number">0</span>; <span class="comment">// 最大价值</span></span><br><span class="line">	Package();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getBest</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">3</span>; <span class="comment">// 物品数量</span></span><br><span class="line">	<span class="keyword">int</span> content = <span class="number">30</span>; <span class="comment">// 背包容量</span></span><br><span class="line">	<span class="keyword">int</span> w[num] = &#123; <span class="number">20</span>,<span class="number">15</span>,<span class="number">15</span> &#125;; <span class="comment">// 物品重量</span></span><br><span class="line">	<span class="keyword">int</span> v[num] = &#123; <span class="number">40</span>,<span class="number">25</span>,<span class="number">25</span> &#125;; <span class="comment">// 物品价值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> currentPrice = <span class="number">0</span>; <span class="comment">// 当前价值</span></span><br><span class="line">	<span class="keyword">int</span> currentPath[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 当前路径</span></span><br><span class="line">	<span class="keyword">int</span> bestPath[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 最优路径</span></span><br><span class="line">	<span class="keyword">int</span> currentWeight = <span class="number">0</span>; <span class="comment">// 当前背包中物品重量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Package.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Package.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Package::getBest</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i 表示搜索树的第i层（根节点为0）</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= num) <span class="comment">// 搜索到了树的最后一层</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (currentPrice &gt; bestPrice) <span class="comment">// 找到更好的结果</span></span><br><span class="line">		&#123;</span><br><span class="line">			bestPrice = currentPrice; <span class="comment">// 重新定义最大价值</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)  <span class="comment">// 重新定义最优路径</span></span><br><span class="line">			&#123;</span><br><span class="line">				bestPath[i] = currentPath[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++)</span><br><span class="line">		&#123;</span><br><span class="line">			currentPath[i] = t; <span class="comment">// 选择当前物品（t=0 表示不放入背包，t=1表示放入背包）</span></span><br><span class="line">			<span class="keyword">if</span> (currentWeight + t * w[i] &lt;= content)</span><br><span class="line">			&#123;</span><br><span class="line">				currentWeight += t * w[i];<span class="comment">// 更新当前重量</span></span><br><span class="line">				currentPrice += t * v[i];<span class="comment">//更新当前价值</span></span><br><span class="line">				getBest(i + <span class="number">1</span>);<span class="comment">// 继续搜索下一层</span></span><br><span class="line">				currentWeight -= t * w[i];<span class="comment">//回溯</span></span><br><span class="line">				currentPrice -= t * v[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Package::Package() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mian.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Package.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Package p;</span><br><span class="line">	p.getBest(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p.bestPrice &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看看可以看到，0 1 背包的实际代码与上图中代码逻辑是一致的。（有时候，对算法的总结抽象很重要）</p>
<p>之前甚至目前我学习算法，觉得算法描述与实际代码之间相隔很远，就算给我算法描述我可能也无法写出代码。实际上，算法描述与代码之间确实有一定差距，而这差距就需要我们自己进行编程解决，比如 上图描述子集树的算法中output函数，算法描述很简单，但是需要我们按照我们的<strong>实际要求</strong>进行填充。</p>
<h5 id="剪枝优化："><a href="#剪枝优化：" class="headerlink" title="剪枝优化："></a>剪枝优化：</h5><p>上面的的代码中其实已经进行了一步剪枝操作（所谓剪枝，就是提前将不符合条件的去掉），在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (currentWeight + t * w[i] &lt;&#x3D; content)</span><br></pre></td></tr></table></figure>

<p>处判断是否符合背包容量要求来进行剪枝避免无效搜索。</p>
<p>除此之外，当目前已经放入背包中的物品的价值 + 还没有考虑的物品总价值 仍然小于 目前得到的最大价值bestPrice时， 就没有继续搜索下去的必要了，就可以进行剪枝。</p>
<p>添加剪枝函数bound后的代码：</p>
<p>Package.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Package</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> bestPrice = <span class="number">0</span>; <span class="comment">// 最大价值</span></span><br><span class="line">	Package();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getBest</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">bound</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">// 对于剩下的总物品的价值比当前所计算出物品总价值小的情况进行剪枝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">3</span>; <span class="comment">// 物品数量</span></span><br><span class="line">	<span class="keyword">int</span> content = <span class="number">30</span>; <span class="comment">// 背包容量</span></span><br><span class="line">	<span class="keyword">int</span> w[num] = &#123; <span class="number">20</span>,<span class="number">15</span>,<span class="number">15</span> &#125;; <span class="comment">// 物品重量</span></span><br><span class="line">	<span class="keyword">int</span> v[num] = &#123; <span class="number">40</span>,<span class="number">25</span>,<span class="number">25</span> &#125;; <span class="comment">// 物品价值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> currentPrice = <span class="number">0</span>; <span class="comment">// 当前价值</span></span><br><span class="line">	<span class="keyword">int</span> currentPath[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 当前路径</span></span><br><span class="line">	<span class="keyword">int</span> bestPath[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 最优路径</span></span><br><span class="line">	<span class="keyword">int</span> currentWeight = <span class="number">0</span>; <span class="comment">// 当前背包中物品重量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Package.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Package.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Package::getBest</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i 表示搜索树的第i层（根节点为0）</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= num) <span class="comment">// 搜索到了树的最后一层</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (currentPrice &gt; bestPrice) <span class="comment">// 找到更好的结果</span></span><br><span class="line">		&#123;</span><br><span class="line">			bestPrice = currentPrice; <span class="comment">// 重新定义最大价值</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)  <span class="comment">// 重新定义最优路径</span></span><br><span class="line">			&#123;</span><br><span class="line">				bestPath[i] = currentPath[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)</span><br><span class="line">		&#123;</span><br><span class="line">			currentPath[i] = t; <span class="comment">// 选择当前物品（0 表示不放入背包，1表示放入背包）</span></span><br><span class="line">			<span class="keyword">if</span> (currentWeight + t * w[i] &lt;= content &amp;&amp; bound(i))</span><br><span class="line">			&#123;</span><br><span class="line">				currentWeight += t * w[i];<span class="comment">// 更新当前重量</span></span><br><span class="line">				currentPrice += t * v[i];<span class="comment">//更新当前价值</span></span><br><span class="line">				getBest(i + <span class="number">1</span>);<span class="comment">// 继续搜索下一层</span></span><br><span class="line">				currentWeight -= t * w[i];</span><br><span class="line">				currentPrice -= t * v[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当剩下的所有物品全都放入背包仍不能超过当前所找到的最大价值时，进行剪枝</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Package::bound</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> tempPrice = currentPrice;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = i; t &lt;= num; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		tempPrice += v[t];</span><br><span class="line">		<span class="keyword">if</span> (tempPrice &gt; bestPrice)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Package::Package() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="子集树实例：n皇后问题"><a href="#子集树实例：n皇后问题" class="headerlink" title="子集树实例：n皇后问题"></a>子集树实例：n皇后问题</h4><p>直接看代码：</p>
<p>NQueen.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NQueen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> row_length = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> chessboard[row_length][row_length] = &#123; <span class="number">0</span> &#125;;<span class="comment">// 棋盘</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> chessboard[][row_length], <span class="keyword">int</span> row)</span></span>; <span class="comment">// 放置棋子</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printChessboard</span><span class="params">(<span class="keyword">int</span> chessboard[row_length][row_length])</span></span>; <span class="comment">// 打印棋盘</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isVaild</span><span class="params">(<span class="keyword">int</span> chessboard[][row_length], <span class="keyword">int</span> row, <span class="keyword">int</span> index)</span></span>; <span class="comment">// 提前检查放置在(row,index)的棋子是否合法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>NQueen.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"NQueen.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen::place</span><span class="params">(<span class="keyword">int</span> chessboard[][row_length], <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (row &gt; row_length - <span class="number">1</span>) <span class="comment">// 递归终止条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		printChessboard(chessboard);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_length; i++) <span class="comment">// 对row行的每一列进行判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isVaild(chessboard, row, i)) <span class="comment">// 如果合法</span></span><br><span class="line">		&#123;</span><br><span class="line">			chessboard[row][i] = <span class="number">1</span>;</span><br><span class="line">			place(chessboard, row + <span class="number">1</span>); <span class="comment">// 进入下一行</span></span><br><span class="line">			chessboard[row][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NQueen::isVaild</span><span class="params">(<span class="keyword">int</span> chessboard[][row_length], <span class="keyword">int</span> row, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 查找竖向是否有棋子</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (chessboard[i][index] == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找横向是否有棋子</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (chessboard[row][i] == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找 斜率为正的方向是否有棋子</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row_length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((index != j &amp;&amp; row != i ) &amp;&amp; <span class="built_in">abs</span>((index - j) / (row - i)) == <span class="number">1</span> &amp;&amp; chessboard[i][j] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen::printChessboard</span><span class="params">(<span class="keyword">int</span> chessboard[][row_length])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row_length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row_length; j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; chessboard[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码注释解释的很详细了。这里要说明的是这里和普通的子集树又不一样，平常的子集树的一维的，但是这里等于是二维的。但是<strong>回溯的思想</strong>是一样的。</p>
<h4 id="子集树实例：最大团问题"><a href="#子集树实例：最大团问题" class="headerlink" title="子集树实例：最大团问题"></a>子集树实例：最大团问题</h4><p>一个无向图 G=(V，E)，V 是点集，E 是边集。取 V 的一个子集 U，若对于 U 中任意两个点 u 和 v，有边 (u,v)∈E，那么称 U 是 G 的一个完全子图。 U 是一个团当且仅当 U 不被包含在一个更大的完全子图中。</p>
<p>G的最大团指的是定点数最多的一个团。</p>
<p>直接看代码就可以：</p>
<p>MaxClique.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxClique</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> point_num = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> bestPath[point_num] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 选择过程中产生的相对优的路径</span></span><br><span class="line">	<span class="keyword">int</span> currentPointNum = <span class="number">0</span>; <span class="comment">// 当前团中节点的数量</span></span><br><span class="line">	<span class="keyword">int</span> bestPointNum = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getMaxClique</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isClique</span><span class="params">(<span class="keyword">int</span> currentPath[point_num], <span class="keyword">int</span> <span class="built_in">point</span>)</span></span>;<span class="comment">// 判断point是否与currentPath中的所有节点都有边相连</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">point</span>[point_num] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> graph[point_num][point_num] = &#123; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">										&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">										&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">										&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">										&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> currentPath[point_num] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>MaxClique.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MaxClique.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最大团使用子集树的算法进行解决</span></span><br><span class="line"><span class="comment">对本问题中使用的currentPath进行说明：例如节点标号&#123;1,2,3&#125;,currentPath[3] = &#123; 1,0,1&#125;, 即表示节点 1,3 构成最大团</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxClique::getMaxClique</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t &gt; point_num - <span class="number">1</span>) <span class="comment">// 递归终止条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (currentPointNum &gt; bestPointNum)</span><br><span class="line">		&#123;</span><br><span class="line">			bestPointNum = currentPointNum;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; point_num; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				bestPath[i] = currentPath[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isClique(currentPath, t)) <span class="comment">// 如果与团中每个节点都有边相连</span></span><br><span class="line">	&#123;</span><br><span class="line">		currentPath[t] = <span class="number">1</span>; <span class="comment">// 将该节点加入到团中</span></span><br><span class="line">		currentPointNum++; <span class="comment">//团中节点数+1</span></span><br><span class="line">		getMaxClique(t + <span class="number">1</span>);</span><br><span class="line">		currentPointNum--;<span class="comment">//回溯</span></span><br><span class="line">		currentPath[t] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		currentPath[t] = <span class="number">0</span>;</span><br><span class="line">		getMaxClique(t + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MaxClique::isClique</span><span class="params">(<span class="keyword">int</span> currentPath[point_num], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">// n 表示的是节点的索引值，从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; point_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (currentPath[i] == <span class="number">1</span> &amp;&amp; graph[<span class="built_in">point</span>[i] - <span class="number">1</span>][n] == <span class="number">0</span>) <span class="comment">// 节点n与当前团中的节点存在不相连的情况</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MaxClique.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	MaxClique clique;</span><br><span class="line">	clique.getMaxClique(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clique.point_num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; clique.bestPath[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，还以使用子集树一样的套路，不过这里要注意的是需要根据不同的题来进行不同的具体使用。</p>
<p>例如这个题，再像处理0 1 背包那样（如下图的操作）</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200327194737.png" alt=""></p>
<p>就不行了，这里要通过if else 来代替for 循环，这样可以更好的判断向已有的团中加入一个节点是否满足团的条件。</p>
<p>根据具体情况进行具体分析的能力和思想很重要。算法只能提供给我们一种思想，但是我们不能把这种思想僵化为一种固定模式，算法是动态随机应变的。</p>
<h4 id="排列树实例：全排列问题"><a href="#排列树实例：全排列问题" class="headerlink" title="排列树实例：全排列问题"></a>排列树实例：全排列问题</h4><p>比如：集合{ 1,2,3}的全排列为：</p>
<p>{ 1 2 3} </p>
<p>{ 1 3 2 }</p>
<p>{ 2 1 3 }</p>
<p>{ 2 3 1 }</p>
<p>{ 3 2 1 }</p>
<p>{ 3 1 2 }</p>
<p>通过全排列问题可以找到排列树的实质原理，因为排列树就是对一个序列进行全排列。</p>
<p>直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[length] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//起始位置</span></span><br><span class="line">	<span class="keyword">int</span> a[length] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="built_in">getResult</span>(a, start);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt; length - <span class="number">1</span>) <span class="comment">// 递归终止条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		printArray(a, length);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; length; i++) &#123;</span><br><span class="line">		swap(a[start], a[i]); <span class="comment">// 这个交换操作是重点，目的就是通过递归交换两个元素的位置，达到全排列的目的</span></span><br><span class="line">		<span class="built_in">getResult</span>(a, start + <span class="number">1</span>);</span><br><span class="line">		swap(a[start], a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="排列树实例：解决TSP问题："><a href="#排列树实例：解决TSP问题：" class="headerlink" title="排列树实例：解决TSP问题："></a>排列树实例：解决TSP问题：</h4><p>TSP问题解决可以使用排列树，排列树的算法描述为：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200326145736.png" alt=""></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200325232458.png" alt=""></p>
<p>TSP.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TSP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> city_num = <span class="number">5</span>; <span class="comment">// 城市数量</span></span><br><span class="line">	<span class="keyword">int</span> bestPath[city_num+<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">// 最优路径经过的城市编号</span></span><br><span class="line">	<span class="keyword">int</span> bestLength = <span class="number">200</span>; <span class="comment">// 每次搜索中得到的最优路径长度,初始设置一个大值</span></span><br><span class="line">	<span class="keyword">int</span> start_city = <span class="number">0</span>; <span class="comment">// 开始城市在数组中的索引</span></span><br><span class="line">	<span class="keyword">int</span> city[city_num] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;; <span class="comment">// 城市编号，为方便使用数字</span></span><br><span class="line">	TSP();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">getTSP</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> city)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isInPath</span><span class="params">(<span class="keyword">int</span> city)</span></span>; <span class="comment">// 判断当前城市是否已经别选中了</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isHasRoute</span><span class="params">(<span class="keyword">int</span> city1 , <span class="keyword">int</span> city2 )</span></span>; <span class="comment">//判断另个城市之间是否有通道</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> length[city_num][city_num] = &#123; &#123;<span class="number">-1</span>, <span class="number">10</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">12</span>&#125;,</span><br><span class="line">										&#123;<span class="number">10</span>, <span class="number">-1</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">5</span> &#125;,</span><br><span class="line">										&#123;<span class="number">-1</span>, <span class="number">15</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">30</span> &#125;,</span><br><span class="line">										&#123;<span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">6</span> &#125;,</span><br><span class="line">										&#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">-1</span>&#125; &#125;; <span class="comment">// 城市之间的距离，-1表示城市之间没有通路</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> currentPath[city_num] = &#123; <span class="number">0</span> &#125;; <span class="comment">//在寻找最优路径过程中搜索的路径中城市编号</span></span><br><span class="line">	<span class="keyword">int</span> currentLength = <span class="number">0</span>; <span class="comment">//在寻找最优路径过程中搜索的路径长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TSP.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于TSP问题，需要通过排列树进行搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TSP.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">TSP::TSP() &#123;</span><br><span class="line">	currentPath[<span class="number">0</span>] = city[start_city]; <span class="comment">// 提前设置起始点</span></span><br><span class="line">	bestPath[city_num] = city[start_city];  <span class="comment">// 提前设置终止点（与起始点相同） </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TSP::getTSP</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// i 表示搜索树的第几层；n表示对第i层的编号为n的进行操作</span></span><br><span class="line">	<span class="keyword">if</span> (i == city_num - <span class="number">1</span>) <span class="comment">// 到达了搜索树最后一层</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isHasRoute(city[start_city], currentPath[city_num - <span class="number">1</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (currentLength + length[start_city][currentPath[city_num - <span class="number">1</span>] - <span class="number">1</span>] &lt; bestLength) <span class="comment">// 当找到更好的路径</span></span><br><span class="line">			&#123;</span><br><span class="line">				bestLength = currentLength + length[start_city][currentPath[city_num - <span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; city_num; t++)</span><br><span class="line">				&#123;</span><br><span class="line">					bestPath[t] = currentPath[t];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; city_num; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isHasRoute(n, city[t]) &amp;&amp; !isInPath(city[t])) <span class="comment">// 寻找到和当前城市n有直接相连的城市，并且该城市还没有被选择</span></span><br><span class="line">		&#123;</span><br><span class="line">			currentPath[i + <span class="number">1</span>] = city[t]; <span class="comment">//将当前城市纳入考虑范围</span></span><br><span class="line">			currentLength += length[n - <span class="number">1</span>][city[t] - <span class="number">1</span>]; <span class="comment">// 将当前路径纳入考虑范围。注意由于我是将城市按数字进行编号，因此通过n-1就可以得到城市在数组中的索引</span></span><br><span class="line">			getTSP(i + <span class="number">1</span>, city[t]); <span class="comment">// 这里解释一下，之所以传递第二个参数是因为在下次递归中需要知道新选择节点编号（这样才能找到与新城市相邻的城市）</span></span><br><span class="line">			currentPath[i + <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 回溯</span></span><br><span class="line">			currentLength -= length[n - <span class="number">1</span>][city[t] - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断城市（编号）是否已经在已选择路径中了</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TSP::isInPath</span><span class="params">(<span class="keyword">int</span> city)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; city_num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (city == currentPath[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个城市（编号）之间是否直接相连</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TSP::isHasRoute</span><span class="params">(<span class="keyword">int</span> city1, <span class="keyword">int</span> city2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 由于这里我使用的是数字来表示城市的，所以对于判断城市之间是否直接相连比较方便，城市编号-1就可以作为索引。但是实际情况要复杂</span></span><br><span class="line">	<span class="keyword">if</span> (length[city1 - <span class="number">1</span>][city2 - <span class="number">1</span>] != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TSP.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TSP tsp;</span><br><span class="line">	tsp.getTSP(<span class="number">0</span>, tsp.city[tsp.start_city]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tsp.city_num + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tsp.bestPath[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"最优:"</span> &lt;&lt; tsp.bestLength &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是我自己写的，因为我把排列树的基本忘了，我就按着自己的理解写了。虽然最后结果是正确的，但是很显然代码质量很差，<strong>我在编码的过程中感觉自己想的有些复杂</strong>，但是又不能写出更好的。硬着头皮写完后参考了网上的资料。其实按着求全排列那样写就可以。</p>
<h4 id="回溯算法其他问题："><a href="#回溯算法其他问题：" class="headerlink" title="回溯算法其他问题："></a>回溯算法其他问题：</h4><h5 id="子集树解决装载问题"><a href="#子集树解决装载问题" class="headerlink" title="子集树解决装载问题 :"></a>子集树解决装载问题 :</h5><p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200327104450.png" alt=""></p>
<h5 id="leetcode-Letter-Combinations-of-a-Phone-Number"><a href="#leetcode-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="leetcode Letter Combinations of a Phone Number"></a>leetcode Letter Combinations of a Phone Number</h5><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p>
<p>经过这个题可以发现，对于回溯问题，并不是所有的要使用子集树或排列树，比如当寻找[a,b,c] 和 [d,e,f]的搭配时(ad,ae..) ，子集树和排列树好像都不那么合适，这时候就需要具体问题具体分析了：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200331230448.png" alt=""></p>
<h4 id="回溯法时间复杂度"><a href="#回溯法时间复杂度" class="headerlink" title="回溯法时间复杂度"></a>回溯法时间复杂度</h4><p>一般用回溯法都是一些NP问题。</p>
<p>回溯法的最坏复杂度就是无解的时候。因为想证明无解就得否定所有的解，也就是说会考虑所有的可能成为解的情况。</p>
<p>例如用排列树皇后问题，复杂度是O(n!),因为等价于找到1～n的其中一个排列。</p>
<p>又例如01背包，当然在容量以及物品的体积在一个比较小的范围可以动态规划。然而在一般情形，只能搜索2^n种情况。所以就是O(2^n).</p>
<p>基本上回溯法就是两种复杂度，指数或者阶乘。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP与HTTPS握手的那些事</title>
    <url>/2020/03/16/HTTP%E4%B8%8EHTTPS%E6%8F%A1%E6%89%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>这篇文章的起因是我在看《计算机网络自顶向下方法》时有一个题目答案中说：SMTP在应用层使用握<br>手，而HTTP不使用握手  。由于我对计算机网络掌握还不是很清楚，我就有了疑问，我知道TCP有三次握手，但是应用层的协议也有握手吗？为啥HTTP没有握手呢？</p>
<p>答：应用层也有握手；HTTP没有握手，但是HTTPS有握手，具体的看下面解释吧。</p>
<p>今天我总结了什么是HTTP三次握手，还有HTTPS握手的过程以及为什么HTTPS是安全的。</p>
<p><strong>前提</strong></p>
<p>在讲述这两个握手时候，有一些东西需要提前说明。</p>
<p><strong>HTTP与TCP/IP区别？</strong></p>
<p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p>
<p>下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI（Open System Interconnect）模型中的位置：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316111824.png" alt=""></p>
<p>PS：表格来自网上资料</p>
<p><strong>CA证书是什么？</strong></p>
<p>CA（Certificate Authority）是负责管理和签发证书的第三方权威机构，是所有行业和公众都信任的、认可的。</p>
<p>CA证书，就是CA颁发的证书，可用于验证网站是否可信（针对HTTPS）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</p>
<p>例如我们熟悉的github，使用的是https，见下图</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112707.png" alt=""></p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112736.png" alt=""></p>
<p>比如爱课程，使用的就是http，见下图：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112830.png" alt=""></p>
<p><strong>HTTP三次握手</strong></p>
<p>HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。而关于HTTP的三次握手，其实就是使用三次TCP握手确认建立一个HTTP连接。</p>
<p>如下图所示，SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200329105243.png" alt=""></p>
<p>PS：图片来自网上资料</p>
<p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p><strong>HTTPS握手过程</strong></p>
<p>HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。具体是如何进行加密，解密，验证的，且看下图，下面的称为一次握手。</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112001.png" alt=""></p>
<p>PS：图片以下描述摘自：<a href="http://zhuqil.cnblogs.com/" target="_blank" rel="noopener">http://zhuqil.cnblogs.com</a></p>
<p><strong>1. 客户端发起HTTPS请求</strong></p>
<p><strong>2. 服务端的配置</strong></p>
<p>采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p>
<p><strong>3. 传送证书</strong></p>
<p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</p>
<p><strong>4. 客户端解析证书</strong></p>
<p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。</p>
<p><strong>5. 传送加密信息</strong></p>
<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p><strong>6. 服务段解密信息</strong></p>
<p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<p><strong>7. 传输加密后的信息</strong></p>
<p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
<p><strong>8. 客户端解密信息</strong></p>
<p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p>
<p>PS: 整个握手过程第三方即使监听到了数据，也束手无策。</p>
<p><strong>总结</strong></p>
<p><strong>为什么HTTPS是安全的？</strong></p>
<p>在HTTPS握手的第四步中，如果站点的证书是不受信任的，会显示出现下面确认界面，确认了网站的真实性。另外第六和八步，使用客户端私钥加密解密，保证了数据传输的安全。</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112103.png" alt=""></p>
<p><strong>HTTPS和HTTP的区别</strong></p>
<p>\1. https协议需要到ca申请证书或自制证书。</p>
<p>\2. http的信息是明文传输，https则是具有安全性的ssl加密。</p>
<p>\3. http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层），用的端口也不一样，前者是80（需要国内备案），后者是443。</p>
<p>\4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p><strong>注意https加密是在传输层</strong> </p>
<p>https报文在被包装成tcp报文的时候完成加密的过程，无论是https的<strong>header域</strong>也好，body域也罢都是会被加密的。</p>
<p>当使用<strong>tcpdump或者wireshark</strong>之类的tcp层工具抓包，获取是加密的内容，而如果用应用层抓包，使用<strong>Charels(Mac)、Fildder(Windows)</strong>抓包工具，那当然看到是明文的。</p>
<p>PS：HTTPS本身就是为了网络的传输安全。</p>
<p>例子，使用wireshark抓包：</p>
<p>http，可以看到抓到是明文的：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112136.png" alt=""></p>
<p>https，可以看到抓到是密文的：</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200316112213.png" alt=""></p>
<p><strong>附录</strong></p>
<p>HTTPS一般使用的加密与HASH算法如下：</p>
<p>非对称加密算法：RSA，DSA/DSS</p>
<p>对称加密算法：AES，RC4，3DES</p>
<p>HASH算法：MD5，SHA1，SHA256</p>
<p>本文转自：博客园 海角在眼前 <a href="https://www.cnblogs.com/lovesong/" target="_blank" rel="noopener">https://www.cnblogs.com/lovesong/</a>   博主讲解的已经很好了，中间添加了我的些许补充</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP | HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络的特点以及训练过程</title>
    <url>/2020/03/12/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E7%89%B9%E7%82%B9%E4%BB%A5%E5%8F%8A%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="卷积神经网络的特点以及训练过程"><a href="#卷积神经网络的特点以及训练过程" class="headerlink" title="卷积神经网络的特点以及训练过程"></a>卷积神经网络的特点以及训练过程</h2><p>首先明确：卷积神经网络的训练是为了得到<strong>卷积核</strong>，方便之后进行其他操作</p>
<h3 id="卷积神经网络的特点"><a href="#卷积神经网络的特点" class="headerlink" title="卷积神经网络的特点"></a>卷积神经网络的特点</h3><h4 id="1、局部感知："><a href="#1、局部感知：" class="headerlink" title="1、局部感知："></a>1、局部感知：</h4><p>一般认为图像的空间联系是局部的像素联系比较密切，而距离较远的像素相关性较弱，因此，每个神经元没必要对全局图像进行感知，只要对<strong>局部</strong>进行感知，然后在更高层将局部的信息综合起来得到全局信息。</p>
<h4 id="2、参数共享："><a href="#2、参数共享：" class="headerlink" title="2、参数共享："></a>2、参数共享：</h4><p>在局部连接中，每个神经元的参数都是一样的，即：同一个卷积核在图像中都是共享的。（理解：卷积操作实际是在提取一个个局部信息，而局部信息的一些统计特性和其他部分是一样的，也就意味着这部分学到的特征也可以用到另一部分上。所以对图像上的所有位置，都能使用同样的学习特征。）卷积核共享有个问题：提取特征不充分，可以通过<strong>增加多个卷积核</strong>来弥补，可以学习多种特征。</p>
<h4 id="3、采样-池化-层："><a href="#3、采样-池化-层：" class="headerlink" title="3、采样(池化)层："></a>3、采样(池化)层：</h4><p>在通过卷积得到特征后，基于局部相关性原理进行亚采样，在减少数据量的同时保留有用信息。（压缩数据和参数的量，减少过拟合）（max-polling 和average-polling）</p>
<h3 id="多核卷积"><a href="#多核卷积" class="headerlink" title="多核卷积"></a>多核卷积</h3><p>通过<strong>权值共享</strong>可以了解到：用一个卷积核操作只能得到<strong>一部分</strong>的特征，但是得不到全部特征，这时候就必须引入多卷积核来尽可能多的获取图像矩阵的<strong>全部特征</strong>，即每个卷积核学习不同特征（卷积核不同的值）来提取原图特征。</p>
<p>下面图片经过三个卷积核的卷积操作得到三个特征图，每个特征图体现原图不同特征。需要注意的是，在多核卷积的过程中每个卷积核的大小应该是相同的。</p>
<p><img src="https://gzhkevin-image.oss-cn-beijing.aliyuncs.com/img/20200312213105.png" alt=""></p>
<h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p>池化层往往在卷积层后面，通过池化<strong>降低</strong>卷积层输出的特征向量，同时降低<strong>过拟合</strong>发生。</p>
<h3 id="卷积神经网络CNN究竟是怎样一步一步工作"><a href="#卷积神经网络CNN究竟是怎样一步一步工作" class="headerlink" title="卷积神经网络CNN究竟是怎样一步一步工作"></a>卷积神经网络CNN究竟是怎样一步一步工作</h3><p>参考：<a href="https://www.jianshu.com/p/fe428f0b32c1" target="_blank" rel="noopener">https://www.jianshu.com/p/fe428f0b32c1</a></p>
<h3 id="卷积的实际使用"><a href="#卷积的实际使用" class="headerlink" title="卷积的实际使用"></a>卷积的实际使用</h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p>代码中自行实现了卷积的操作，因为使用的卷积核都是对称的，所以不需要对其进行180旋转的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convolve</span><span class="params">(img, fil, mode=<span class="string">'same'</span>)</span>:</span>  <span class="comment"># 分别提取三个通道</span></span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">'fill'</span>:</span><br><span class="line">        h = fil.shape[<span class="number">0</span>] // <span class="number">2</span></span><br><span class="line">        w = fil.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">        img = np.pad(img, ((h, h), (w, w), (<span class="number">0</span>, <span class="number">0</span>)), <span class="string">'constant'</span>)</span><br><span class="line">    conv_b = _convolve(img[:, :, <span class="number">0</span>], fil)  <span class="comment"># 然后去进行卷积操作</span></span><br><span class="line">    conv_g = _convolve(img[:, :, <span class="number">1</span>], fil)</span><br><span class="line">    conv_r = _convolve(img[:, :, <span class="number">2</span>], fil)</span><br><span class="line"></span><br><span class="line">    dstack = np.dstack([conv_b, conv_g, conv_r])  <span class="comment"># 将卷积后的三个通道合并</span></span><br><span class="line">    <span class="keyword">return</span> dstack  <span class="comment"># 返回卷积后的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_convolve</span><span class="params">(img, fil)</span>:</span></span><br><span class="line">    fil_heigh = fil.shape[<span class="number">0</span>]  <span class="comment"># 获取卷积核(滤波)的高度</span></span><br><span class="line">    fil_width = fil.shape[<span class="number">1</span>]  <span class="comment"># 获取卷积核(滤波)的宽度</span></span><br><span class="line"></span><br><span class="line">    conv_heigh = img.shape[<span class="number">0</span>] - fil.shape[<span class="number">0</span>] + <span class="number">1</span>  <span class="comment"># 确定卷积结果的大小</span></span><br><span class="line">    conv_width = img.shape[<span class="number">1</span>] - fil.shape[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    conv = np.zeros((conv_heigh, conv_width), dtype=<span class="string">'uint8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(conv_heigh):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(conv_width):  <span class="comment"># 逐点相乘并求和得到每一个点</span></span><br><span class="line">            conv[i][j] = wise_element_sum(img[i:i + fil_heigh, j:j + fil_width], fil)</span><br><span class="line">    <span class="keyword">return</span> conv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wise_element_sum</span><span class="params">(img, fil)</span>:</span></span><br><span class="line">    res = (img * fil).sum()</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> res &gt; <span class="number">255</span>:</span><br><span class="line">        res = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = plt.imread(<span class="string">"../res/test_jpg.jpg"</span>)  <span class="comment"># 在这里读取图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积核应该是奇数行，奇数列的</span></span><br><span class="line">fil = np.array([[<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>],</span><br><span class="line">                [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">res = convolve(img, fil, <span class="string">'fill'</span>)</span><br><span class="line">plt.imshow(res)  <span class="comment"># 显示卷积后的图片</span></span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>

<h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><p>首先构造一个卷积核（当然在实际使用中是通过训练得到的），然后通过这个卷积核对图像进行操作。</p>
<p>代码中<strong>kernal</strong>即为卷积核，将图片和卷积核都转为numpy类型，然后进行卷积操作。</p>
<h5 id="对图片进行模糊"><a href="#对图片进行模糊" class="headerlink" title="对图片进行模糊"></a>对图片进行模糊</h5><p>假设我们使用图片</p>
<p><img src="https://lodev.org/cgtutor/images/photo3.jpg" alt=""></p>
<p>使用kernal为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.0, 0.2,  0.0,</span><br><span class="line">0.2, 0.2,  0.2,</span><br><span class="line">0.0, 0.2,  0.0</span><br></pre></td></tr></table></figure>

<p>即我们通过将图片局部进行类似平均化的操作，达到模糊目的。</p>
<p>得到结果：</p>
<p><img src="https://lodev.org/cgtutor/images/filterblur.jpg" alt=""></p>
<p>如果我们使用更大的卷积核来对图片操作，kernal设置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0, 0, 1, 0, 0,</span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line">1, 1, 1, 1, 1,</span><br><span class="line">0, 1, 1, 1, 0,</span><br><span class="line">0, 0, 1, 0, 0,</span><br></pre></td></tr></table></figure>

<p>我们会得到更模糊的图片：</p>
<p><img src="https://lodev.org/cgtutor/images/filterblurmore.jpg" alt=""></p>
<h4 id="另外有关图像的锐化，风格转化等更加详细的介绍可以参考下面的网址"><a href="#另外有关图像的锐化，风格转化等更加详细的介绍可以参考下面的网址" class="headerlink" title="**另外有关图像的锐化，风格转化等更加详细的介绍可以参考下面的网址"></a>**另外有关图像的锐化，风格转化等更加详细的介绍可以参考下面的网址</h4><p>我这篇博客就是根据其进行的总结，因为链接这篇文章已经说明的很清晰了，所以我就不再废话了：<a href="https://lodev.org/cgtutor/filtering.html" target="_blank" rel="noopener">https://lodev.org/cgtutor/filtering.html</a></p>
<h3 id="在运行过程中遇到的问题"><a href="#在运行过程中遇到的问题" class="headerlink" title="在运行过程中遇到的问题"></a>在运行过程中遇到的问题</h3><h5 id="关于-jpg-与-png的不同之处"><a href="#关于-jpg-与-png的不同之处" class="headerlink" title="关于 .jpg 与 .png的不同之处"></a>关于 .jpg 与 .png的不同之处</h5><p>对于jpg和png图像的不同之处，之前一直是没有了解，都是混用，但是在这次图像卷积实验中，看出了不同之处。</p>
<p><strong>如果你把上面代码中的.jpg文件改为.png文件，那么就无法得到正常的结果</strong>，为什么呢？</p>
<p>这还要从jpg和png的不同之处说起。</p>
<p>.jpg 是由<strong>三通道</strong>组成的，Red（红色）Green（绿色）Blue（蓝色），也就是说转为numpy后的shape为(x,x,3)</p>
<p>.png是由<strong>四通道</strong>组成的，Red（红色）Green（绿色）Blue（蓝色）和Alpha，其中Alpha通道一般用做透明度参数，这就是为啥透明图像都保存成了png格式，一般在程序开发过程中会用到透明背景的图片，这些图片都是.png类型的。.png图像转为numpy后的shape为(x,x,4)。</p>
<p>这算是自己的无知采坑了吧。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>理解公钥与私钥</title>
    <url>/2020/03/12/%E7%90%86%E8%A7%A3%E5%85%AC%E9%92%A5%E4%B8%8E%E7%A7%81%E9%92%A5/</url>
    <content><![CDATA[<h1 id="理解公钥与私钥"><a href="#理解公钥与私钥" class="headerlink" title="理解公钥与私钥"></a>理解公钥与私钥</h1><h3 id="一、公钥算法与私钥算法"><a href="#一、公钥算法与私钥算法" class="headerlink" title="一、公钥算法与私钥算法"></a>一、公钥算法与私钥算法</h3><p><strong>1、私钥算法</strong></p>
<p><strong>私钥加密算法</strong>，又称 <strong>对称加密算法</strong>，因为这种算法解密密钥和加密密钥是相同的。也正因为同一密钥既用于加密又用于解密，所以这个密钥是不能公开的。常见的有《<a href="http://songlee24.github.io/2014/12/06/des-encrypt/" target="_blank" rel="noopener">DES加密算法</a>》、《<a href="http://songlee24.github.io/2014/12/13/aes-encrypt/" target="_blank" rel="noopener">AES加密算法</a>》。</p>
<p><strong>2、公钥算法</strong></p>
<p><strong>公钥加密算法</strong>，也就是 <strong>非对称加密算法</strong>，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥：</p>
<ul>
<li>公钥和私钥成对出现</li>
<li>公开的密钥叫公钥，只有自己知道的叫私钥</li>
<li>用公钥加密的数据只有对应的私钥可以解密</li>
<li>用私钥加密的数据只有对应的公钥可以解密</li>
<li>如果可以用公钥解密，则必然是对应的私钥加的密</li>
<li>如果可以用私钥解密，则必然是对应的公钥加的密</li>
</ul>
<p>公钥和私钥是相对的，两者本身并没有规定哪一个必须是公钥或私钥。</p>
<h3 id="二、实现数据的安全传输"><a href="#二、实现数据的安全传输" class="headerlink" title="二、实现数据的安全传输"></a>二、实现数据的安全传输</h3><p>要实现数据的安全传输，当然就要对数据进行加密了。</p>
<p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用<strong>非对称算法</strong>，过程如下：</p>
<ol>
<li>首先 接收方 生成一对密钥，即私钥和公钥；</li>
<li>然后，接收方 将公钥发送给 发送方；</li>
<li>发送方用收到的公钥对数据加密，再发送给接收方；</li>
<li>接收方收到数据后，使用自己的私钥解密。</li>
</ol>
<p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p>
<p><a href="http://img.blog.csdn.net/20150502122610368" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20150502122610368" alt=""></a></p>
<h3 id="三、对信息进行数字签名"><a href="#三、对信息进行数字签名" class="headerlink" title="三、对信息进行数字签名"></a>三、对信息进行数字签名</h3><p>除了保证数据的安全传输之外，公钥体系的另一个用途就是对数据进行签名。通常<strong>“数字签名”</strong>是用来验证发送方的身份并帮助保护数据的完整性。</p>
<p>例如：一个发送者 A 想要传些资料给大家，用自己的私钥对资料加密，即签名。这样一来，所有收到资料的人都可以用发送者的公钥进行验证，便可确认资料是由 A 发出来的了。（因为只有Ａ使用私钥签名得到的信息，才能用这个公钥来解） 采用数字签名，可以确认两点：</p>
<ol>
<li>保证信息是由签名者自己签名发送的，签名者不能否认或难以否认。</li>
<li>保证信息自签发后到收到为止未曾作过任何修改。</li>
</ol>
<p>之所以可以确认这两点，是因为用公钥可以解密的必然是用对应的私钥加的密，而私钥只有签名者持有。</p>
<h3 id="四、公钥算法的缺点"><a href="#四、公钥算法的缺点" class="headerlink" title="四、公钥算法的缺点"></a>四、公钥算法的缺点</h3><p>现实中，公钥机制也有它的缺点，那就是<strong>效率非常低</strong>，比常用的私钥算法（如 DES 和 AES）慢上一两个数量级都有可能。所以它不适合为大量的原始信息进行加密。为了同时兼顾安全和效率，我们通常结合使用公钥算法和私钥算法：</p>
<ol>
<li>首先，发送方使用对称算法对原始信息进行加密。</li>
<li>接收方通过公钥机制生成一对密钥，一个公钥，一个私钥。</li>
<li>接收方 将公钥发送给 发送方。</li>
<li>发送方用公钥对对称算法的密钥进行加密，并发送给接收方。</li>
<li>接收方用私钥进行解密得到对称算法的密钥。</li>
<li>发送方再把已加密的原始信息发送给接收方。</li>
<li>接收方使用对称算法的密钥进行解密。</li>
</ol>
<p><a href="http://img.blog.csdn.net/20150502122733376" target="_blank" rel="noopener"><img src="http://img.blog.csdn.net/20150502122733376" alt=""></a></p>
<p><strong>总结：</strong></p>
<ol>
<li><p>每个用户都有一对私钥和公钥。</p>
<ul>
<li>私钥用来进行解密和签名，是给自己用的。</li>
<li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li>
</ul>
</li>
<li><p>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。</p>
</li>
<li><p>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。</p>
</li>
</ol>
<p>图片来源：<a href="http://www.cnblogs.com/chnking/archive/2007/08/30/875947.html" target="_blank" rel="noopener">www.cnblogs.com/chnking/archive/2007/08/30/875947.html</a></p>
<p>本文转自：<a href="https://songlee24.github.io/2015/05/03/public-key-and-private-key/" target="_blank" rel="noopener">https://songlee24.github.io/2015/05/03/public-key-and-private-key/</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>
